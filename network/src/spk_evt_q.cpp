#include <arrayfire.h>
#include <cstdint>
#include <vector>

#include "network.h"
#include "neuron.h"
#include "synapse.h"
#include "spk_evt_q.h"
#include "netparams.h"

void SpikeEvents::propagate(SpikeEvents * spkEvt, Network *root, bool excSrc, bool excTar) 
{

	uint32_t index = spkEvt->increment();
	uint32_t size = spkEvt->w[index].size();

	if (size == 0) return;

	// Allocate memory on the device
	af::array w_loc = af::constant(0, size, 1, af::f32);
	af::array lu_loc = af::constant(0, size, 1, af::f32);
	af::array dwdt_loc = af::constant(0, size, 1, af::f32);
	af::array u_loc = af::constant(0, size, 1, af::f32);
	af::array R_loc = af::constant(0, size, 1, af::f32);
	af::array lastArr_loc = af::constant(0, size, 1, af::u32);	

	float** wTemp = spkEvt->getW(index);
	float** 
	
	// Transfer variables from their locations in memory as
	// pointers in the event queue to contiguous arrays for
	// processing
	gfor(seq i, size)
	{
		w_loc(i, 0) = *(*(spkEvt->w)[index][i]);
		lu_loc(i, 0) = *(*(spkEvt->lu)[index][i]);
		dwdt_loc(i, 0) = *(*(spkEvt->dwdt)[index][i]);
		u_loc(i, 0) = *(*(spkEvt->u)[index][i]);
		R_loc(i, 0) = *(*(spkEvt->R)[index][i]);
		lastArr_loc(i, 0) = *(*(spkEvt->lastArr)[index][i]);
	}

	af::array lastSpkTime_loc(dims(0,size), *(spkEvt->lastSpkTime)[index].data())

	//Update synaptic weights using dwdt generated by STDP at
	// last weight update.
	dwdt_loc = TIME_STEP * (root->simTime - lu_loc) * dwdt_loc; 
	Synapse::weightChange(&w_loc, &dwdt_loc);

	// Change weight based on STDP
	if (excSrc && exTar)
	{
		Synapse::stdp_EE_Type1(&lastSpkTime_loc, &lastArr_loc, &w_loc, &dwdt_loc);
	} else if (exSrc && !exTar) {
		Synapse::stdp_EI_Type1(&lastSpkTime_loc, &lastArr_loc, &w_loc, &dwdt_loc);
	} else if (!exSrc && exTar) {
		Synapse::stdp_IE_Type1(&lastSpkTime_loc, &lastArr_loc, &w_loc, &dwdt_loc);
	} else {
		Synapse::stdp_II_Type1(&lastSpkTime_loc, &lastArr_loc, &w_loc, &dwdt_loc);
	}

	gfor(seq i, size)
	{
		*(*(spkEvt->dw)[index][i]) = dwdt_loc(0,i);
		*(*(spkEvt->w)[index][i]) = w_loc(0,i);
		*(*(spkEvt->lu)[index][i]) = root->simTime;
	}

	// Perform UDF short term plasticity
	af::array U_loc(dims(size, 1), *(spkEvt->U)[index].data());
	af::array D_loc(dims(size, 1), *(spkEvt->D)[index].data());
	af::array F_loc(dims(size, 1), *(spkEvt->F)[index].data());
	af::array ISI = lastArr_loc - root->simTime;

	u_loc = U_loc + (u_loc * (1-U_loc) * af::exp(ISI/F_loc))
	R_loc = 1 + ((R_loc - (u_loc * R_loc) -1) * af::exp(ISI/D_loc));
	af::array PSR = UDF_GAIN * R_loc * w_loc * u_loc;

	gfor(seq i, size) 
	{
		*(*(spkEvt->I_dest[i])) += PSR(i, 0);
		*(*(spkEvt->lastArr)[index][i]) = lastArr_loc(0,i);
	}


}

 uint32_t incrementIndex()
 {
 	if (index >= maxSize) {
 		index = 0;
 		return index;
 	}
 	return index++;
 }

void SpikeEvents::clear(uint32_t index)
{
	(this->w[index])->clear();
	(this->dw[index])->clear();
	(this->lu[index])->clear();
	(this->u[index])->clear();
	(this->R[index])->clear();
	(this->lastArr[index])->clear();
	(this->lastSpkTime[index])->clear();
	(this->U[index])->clear();
	(this->D[index])->clear();
	(this->F[index])->clear();
}

void addEvent(	float		*w_,
				float		*dw_,
				float		*lu_,
				float		*u_,
				float		*R,
				uint32_t	*lastArr,
				uint32_t 	lastSpkTime,
				float 		U,
				float 		D,
				float 		F);

float** getW();
float** getDwDt();
float** get_u();
float** getR();
uint32_t** getLastArr();
uint32_t** getLu();
uint32_t* getLastSpkTime();
float* getU();
float* getD();
float* getF();
